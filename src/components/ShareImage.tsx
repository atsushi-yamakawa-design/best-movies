import { useRef, useEffect, useState } from "react";
import style from "./ShareImage.module.scss";

// ã‚¢ã‚¤ã‚³ãƒ³ç´ æ
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
  faArrowUpFromBracket,
  faCircle,
  faCircleDown
} from "@fortawesome/free-solid-svg-icons";

interface ImagePageProps {
  backgroundUrl: string;
  movieImageUrls: string[];
  movieTitles: string[];
}

const ShareImage = ({
  backgroundUrl,
  movieImageUrls,
  movieTitles
}: ImagePageProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    if (canvasRef.current) {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext("2d");
      const topThreeMovieImageUrls = movieImageUrls.slice(0, 3);
      const imagesToLoad = [backgroundUrl, ...topThreeMovieImageUrls];
      const imagePositions = [
        { x: 0, y: 0 }, // èƒŒæ™¯ç”»åƒ
        { x: 220, y: 380 },
        { x: 220, y: 690 },
        { x: 220, y: 1000 }
      ];

      if (ctx) {
        Promise.all(
          imagesToLoad.map((src) => {
            return new Promise<HTMLImageElement>((resolve) => {
              const img = new Image();
              img.crossOrigin = "anonymous"; //CORSã‚¨ãƒ©ãƒ¼å¯¾ç­–
              img.onload = () => resolve(img);
              img.src = src;
            });
          })
        ).then((images) => {
          images.forEach((img, index) => {
            // ç”»åƒã®æç”»
            const position = imagePositions[index];
            const ratio = img.naturalHeight / img.naturalWidth;
            const height =
              index === 0
                ? (img.naturalHeight / img.naturalWidth) * canvas.width
                : 170 * ratio;
            ctx.drawImage(
              img,
              position.x,
              position.y,
              index === 0 ? canvas.width : 190,
              height
            );
          });

          // 3ç•ªç›®ã¾ã§ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»
          movieTitles.slice(0, 3).forEach((title, index) => {
            ctx.fillStyle = "white";
            ctx.font = "bold 60px Arial";
            const position = imagePositions[index + 1];
            const textX = position.x + 190 + 30;
            const imageHeight =
              170 *
              (images[index + 1].naturalHeight /
                images[index + 1].naturalWidth);
            const textY = position.y + imageHeight / 2 - 20;
            wrapText(ctx, title || "ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ãªã—ï¼‰", textX, textY, 640, 70);
          });

          // 4ç•ªç›®ä»¥é™ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»
          let startY = 840 + 170 * 3;
          movieTitles.slice(3).forEach((title, index) => {
            const dynamicTitle = `${index + 4}. ${title || "ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ãªã—ï¼‰"}`;
            ctx.font = "bold 46px Arial";
            const textX = 120;
            let textY = startY;
            const textHeight = wrapText(
              ctx,
              dynamicTitle,
              textX,
              textY,
              960,
              64
            );
            startY += textHeight + 24;
          });
        });
      }
    }
  }, [backgroundUrl, movieImageUrls, movieTitles]);

  // ã‚·ã‚§ã‚¢ç”¨ã®ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ
  const createShareText = (titles: string[]) => {
    let shareText = "My Best Movies 2023\n\n";

    // ãƒˆãƒƒãƒ—3ã®æ˜ ç”»ã‚¿ã‚¤ãƒˆãƒ«ã®ã¿ã‚’è¿½åŠ 
    for (let i = 0; i < titles.length && i < 3; i++) {
      const title = titles[i];
      let medal = "";
      switch (i) {
        case 0:
          medal = "ğŸ¥‡ ";
          break;
        case 1:
          medal = "ğŸ¥ˆ ";
          break;
        case 2:
          medal = "ğŸ¥‰ ";
          break;
        default:
          break; // ãƒˆãƒƒãƒ—3ä»¥å¤–ã¯ç„¡è¦–
      }
      shareText += `${medal}${title}\n`;
    }
    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã®å¾Œã‚ã«æ”¹è¡Œã‚’2ã¤è¿½åŠ 
    shareText += "\n\n";
    // ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆãƒ†ã‚­ã‚¹ãƒˆã®è¿½åŠ 
    let shareTextCredit = "generated by myBestMovie.com\n#myBestMovieOf2023";
    return shareText + shareTextCredit;
  };

  const shareCanvas = async () => {
    if (navigator.share && canvasRef.current) {
      const canvas = canvasRef.current;
      const shareText = createShareText(movieTitles);
      canvas.toBlob((blob) => {
        if (blob) {
          const file = new File([blob], "image.png", { type: "image/png" });
          navigator
            .share({
              files: [file],
              title: "My Best Movies 2023 ",
              text: shareText
            })
            .then(() => {
              console.log("å…±æœ‰ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ"); // å…±æœ‰ãŒé–‹å§‹ã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã™ã‚¢ãƒ©ãƒ¼ãƒˆ
            })
            .catch((error) => {
              console.error("Error sharing the image", error);
            });
        } else {
          alert("BlobãŒnullã§ã™");
          console.error("Failed to convert the canvas to a blob");
        }
      }, "image/png");
    } else {
      alert("ãƒ¢ãƒã‚¤ãƒ«ãƒ‡ãƒã‚¤ã‚¹ã®ã¿å¯¾å¿œã—ã¦ã„ã¾ã™");
      console.log(
        "Web Share API is not supported in your browser, or canvas is null."
      );
    }
  };

  const downloadCanvas = () => {
    if (canvasRef.current) {
      const canvas = canvasRef.current;
      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿URLã‚’ä½œæˆ
      const imageUrl = canvas.toDataURL("image/png");

      // ãƒªãƒ³ã‚¯ã‚’ä½œæˆã—ã€URLã¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å±æ€§ã‚’è¨­å®š
      const link = document.createElement("a");
      link.href = imageUrl;
      link.download = "my-best-movies.png";

      // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«è¿½åŠ ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’ãƒˆãƒªã‚¬ãƒ¼
      document.body.appendChild(link);
      link.click();

      // å¾Œå‡¦ç†
      document.body.removeChild(link);
    } else {
      console.log("ã‚­ãƒ£ãƒ³ãƒã‚¹ãŒnullã§ã™ã€‚ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã€‚");
    }
  };

  return (
    <div className={style.canvasContainer}>
      <canvas ref={canvasRef} width="1179" height="2229" />
      <button onClick={shareCanvas} className={style.shareButton}>
        å…±æœ‰ã™ã‚‹
        <FontAwesomeIcon icon={faArrowUpFromBracket} className={style.icon} />
      </button>
      <button onClick={downloadCanvas} className={style.downloadButton}>
        <FontAwesomeIcon icon={faCircleDown} className={style.icon} />
      </button>
    </div>
  );
};

export default ShareImage;

function wrapText(
  context: CanvasRenderingContext2D,
  text: string,
  x: number,
  y: number,
  maxWidth: number,
  lineHeight: number,
  dryRun: boolean = false
): number {
  let newHeight = 0;
  const words = text.split(" ");
  let line = "";
  let lineCount = 0; // è¡Œæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹å¤‰æ•°

  for (const word of words) {
    if (lineCount === 2) {
      // 2è¡Œã‚’è¶…ãˆãŸã‚‰çœç•¥è¨˜å·ã‚’è¿½åŠ ã—ã¦å‡¦ç†ã‚’çµ‚äº†
      line += "...";
      if (!dryRun) {
        context.fillText(line, x, y);
      }
      newHeight += lineHeight;
      break;
    }

    // æ—¥æœ¬èªã‹è‹±èªã‹ã«ã‚ˆã£ã¦å‡¦ç†ã‚’å¤‰ãˆã‚‹
    if (isJapanese(word)) {
      // æ—¥æœ¬èªã®å ´åˆã¯æ–‡å­—å˜ä½ã§æ”¹è¡Œ
      for (const char of word) {
        const testLine = line + char;
        if (context.measureText(testLine).width > maxWidth) {
          if (!dryRun) {
            context.fillText(line, x, y);
          }
          line = char;
          y += lineHeight;
          newHeight += lineHeight;
          lineCount++;
          if (lineCount === 2) {
            // 2è¡Œç›®ã«é”ã—ãŸã‚‰æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã§çœç•¥è¨˜å·ã‚’è¿½åŠ 
            break;
          }
        } else {
          line = testLine;
        }
      }
      line += " ";
    } else {
      // è‹±èªã®å˜èªã®å ´åˆã¯å˜èªå˜ä½ã§æ”¹è¡Œ
      const testLine = line + word + " ";
      if (context.measureText(testLine).width > maxWidth) {
        if (!dryRun) {
          context.fillText(line, x, y);
        }
        line = word + " ";
        y += lineHeight;
        newHeight += lineHeight;
        lineCount++;
        if (lineCount === 2) {
          // 2è¡Œç›®ã«é”ã—ãŸã‚‰æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã§çœç•¥è¨˜å·ã‚’è¿½åŠ 
          break;
        }
      } else {
        line = testLine;
      }
    }
  }

  // æœ€å¾Œã®è¡Œã‚’æç”»
  if (!dryRun && line.trim()) {
    context.fillText(line.trim(), x, y);
    newHeight += lineHeight;
  }

  return newHeight;
}

// æ—¥æœ¬èªã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹ç°¡å˜ãªé–¢æ•°
function isJapanese(text: string) {
  return /[\u3000-\u30FF\uFF00-\uFFEF\u4E00-\u9FAF\u3400-\u4DBF]/.test(text);
}
